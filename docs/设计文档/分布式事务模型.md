## 基于局部时间戳的多版本冲突与有效性检测的分布式事务模型

这个事务模型的名字很长，概括来说有4个关健点(此事务模型简称为LMCV，取自4个关健点的英文首字母):

1. **局部时间戳(Local timestamps)**: 分布式数据库集群中每个server或节点独自提供局部时间戳服务
2. **多版本(Multiple version)**: 每条记录会有多个版本
3. **冲突检测(Conflict check)**: 两个写事务同时写同一行记录发生了写写冲突
4. **有效性检测(Validity check)**: 检测事务是否是有效的，是否完全成功


下面举例说明

## 初始状态

假设有三台server: s1、s2、s3，分别存有数据库元素e1、e2、e3 (这里的数据库元素可以简单认为是单行记录) <p>

每个server维护自己的计数器(也就是提供局部时间戳服务)，<br>
计数器为数据库元素提供版本号，版本号即是本地事务的开始时间戳，也是本地事务id的组成部份，<br> 
比如本地事务id: "s1-t1" 就表示在s1上面启动了一个本地事务t1，t1中的数字1就是开始时间戳，<br>
当在t1中更新数据库元素时，本地事务的开始时间戳就当成此数据库元素的版本号。<p>
通过奇偶版本号可以区分事务操作与非事务操作，<br>
这里假设事务操作中得到的版本号和事务id都用奇数表示，而非事务操作用偶数表示。 <p>


计数器初始值如下:
```javascript
所属server  计数器
------------------------------
s1          0
s2          0
s3          0
------------------------------
        表1
```

数据库元素e1、e2、e3的初始值和版本号如下:
```javascript
元素 所属server  值  版本号
------------------------------
e1   s1          0   0
e2   s2          0   0
e3   s3          0   0
------------------------------
        表2
```

## 事务写

一个事务的写操作一般涉及两个阶段: 更新元素阶段、提交阶段

### 1) 更新元素阶段

client启动一个事务，执行下面的操作:
```javascript
e1=1;
e2=2;
e3=3;
```
client向s1、s2、s3发出写请求，
s1、s2、s3都会在本地启动一个本地事务，事务id由计数器生成，

计数器此时变成:
```javascript
所属server  计数器
------------------------------
s1          1
s2          1
s3          1
-----------------------------
        表3
```
对应三个本地事务：
```javascript
s1-t1
s2-t1
s3-t1
```
在这三个本地事务中分别执行client发来的更新请求，<br>
因为每个数据库元素都同时维护多个版本，所以更新操作实际上是插入一条新记录，<br>
此时数据库元素如下(版本号大的排在前面):
```javascript
元素 所属server  值  版本号
------------------------------
e1   s1          1   1
e1   s1          0   0

e2   s2          2   1
e2   s2          0   0

e3   s3          3   1
e3   s3          0   0
------------------------------
        表4
```
如果每个本地事务都没有出异常，那么把本地事务id都返回给client，然后进入第二个阶段，<br>
否则事务结束(可选的，可以执行撤消操作也可以不执行，都没有影响)


### 2) 提交阶段

client在第一个阶段成功执行完之后，会得到一个本地事务id列表: [s1-t1,s2-t1,s3-t1]，<br>
然后把这个本地事务id列表并行发往所有相关server，让它们提交本地事务，

每个server在这一步严格按顺序做下面4件事: 

1. 增加本地计数器，为本地事务获得一个提交时间戳
2. 按元素key进行写写冲突检测，只要当前本地事务的开始时间戳小于上一个事务的提交时间戳就表示发生了写写冲突
3. 更新事务状态表，每个server都在事务状态表中插入一条类似下面表6中的记录
4. 每个server缓存元素的key和提交时间戳(只是一个临时缓存，用于下一个事务的写写冲突检测)

当每个server都完成上面4件事后，

计数器此时变成:
```javascript
所属server  计数器
------------------------------
s1          3
s2          3
s3          3
-----------------------------
        表5
```

事务状态表如下:

```javascript
本地事务id  提交时间戳  所有本地事务id列表
-------------------------------------------
s1-t1       3           s1-t1,s2-t1,s3-t1
s2-t1       3           s1-t1,s2-t1,s3-t1
s3-t1       3           s1-t1,s2-t1,s3-t1
-------------------------------------------
        表6
```

至此，整个事务结束。<br>

如果在第二阶段client收到server的异常，那么撤消其他server的操作(其实也可以不撤消，都没影响)。




## 如何读取数据? 


当需要读取s1上面的e1时，从表4中先取到下面这行
```javascript
元素 所属server  值  版本号
------------------------------
e1   s1          1   1
```
发现它的版本号是1，说明它曾属于某个事务的一部份(奇数版本号代表事务操作)，<br>
但是从这条记录无法判断它是否是正常提交的，<br>
所以要进行有效性检测，把所属server和版本号重新组合为一个本地事务id，<br>
然后从表6的事务状态表中查出"所有本地事务id列表"，<br>
为了更进一步确认事务的有效性，还可以把"所有本地事务id列表"切开来，看看其他本地事务id是否也在事务状态表中，<br>
如果都存在，说明数据库元素e1的值是有效的，<br>
如果不满足条件，那么再找到下面的记录:
```javascript
元素 所属server  值  版本号
------------------------------
e1   s1          0   0
```
此时e1的版本号是0，是个偶数，这代表它是上一个非事务操作得到的值，<br>
非事务操作不需要检查事务状态表，总是有效的。

### 垃圾收集和缓存

在检查事务状态表发现无效的元素后，<br>
可以把此元素的相应版本交给后台的垃圾收集器，定时删除无效元素版本，<br>
避免下次重复读到无效的元素版本。<p>

如果元素是有效的，可以把本地事务id缓存起来，<br>
下次进行有效性检查时先判断缓存，如果缓存没有再从事务状态表中查找。<p>

通过垃圾收集和缓存能有效改进查询性能。<p>

注意，这里的缓存是指在server端的缓存，通过在server端提早过滤掉无效的元素，能减少很多无用的网络传输。